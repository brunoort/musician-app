{"ast":null,"code":"/**\n * Module dependencies\n */\nvar http = require('http'),\n    Request = require('./request'),\n    Response = require('./response'),\n    Q = require('q'),\n    cache = require('./cache'),\n    https = require('https'),\n    logger = require('./logger'),\n    redisTransporter = require('./cache-transporters/redis-transporter'),\n    inMemoryTransporter = require('./cache-transporters/in-memory-transporter'),\n    mongoTransporter = require('./cache-transporters/mongo-transporter');\n\nvar Requestify = function () {\n  'use strict';\n  /**\n   * The response encoding\n   * @type {string}\n   */\n\n  var _responseEncoding = 'utf8',\n\n  /**\n   * Module API\n   */\n  api;\n  /**\n   * Returns http|s instance according to the given protocol\n   * @param protocol\n   * @returns {http|https}\n   */\n\n  function getHttp(protocol) {\n    if (protocol === 'https:') {\n      return https;\n    }\n\n    return http;\n  }\n  /**\n   * Is the request was successful or not\n   * @param {number} code\n   * @returns {boolean}\n   */\n\n\n  function isSuccessful(code) {\n    return code >= 200 && code < 300;\n  }\n  /**\n   * Uses Requestify cache service to store response cache\n   * @param {string} url\n   * @param {int} code\n   * @param {headers} headers\n   * @param {string|object} body\n   * @param {{cache: boolean, expires: number}} cacheSettings\n   */\n\n\n  function storeCache(url, code, headers, body, cacheSettings) {\n    cacheSettings = cacheSettings || {\n      cache: false\n    };\n\n    if (!cacheSettings.cache) {\n      return;\n    }\n\n    cache.set(url, {\n      code: code,\n      headers: headers,\n      body: body,\n      created: new Date().getTime()\n    });\n  }\n  /**\n   * Executes the given request object.\n   * @param {Request} request\n   * @param {Q.defer} defer\n   */\n\n\n  function call(request, defer) {\n    var httpRequest,\n        options,\n        http = getHttp(request.getProtocol()),\n        timeout; // Define options according to Request object interface\n\n    options = {\n      hostname: request.getHost(),\n      path: request.getUri(),\n      port: request.getPort(),\n      method: request.method,\n      auth: request.getAuthorization(),\n      headers: request.getHeaders(),\n      redirect: request.getRedirect()\n    };\n    /**\n     * Handle request callback\n     */\n\n    httpRequest = http.request(options, function (res) {\n      clearTimeout(timeout);\n      var response = new Response(res.statusCode, res.headers);\n      res.setEncoding(_responseEncoding);\n      res.on('data', function (chunk) {\n        response.setChunk(chunk);\n      });\n      res.on('end', function () {\n        if (isSuccessful(response.code)) {\n          storeCache(request.getFullUrl(), response.getCode(), response.getHeaders(), response.body, request.cache);\n          defer.resolve(response);\n          return;\n        }\n\n        if (request.redirect && isRedirect(response.code)) {\n          request.url = response.getHeaders().location;\n          return call(request, defer);\n        }\n\n        defer.reject(response);\n      });\n    });\n    /**\n     * Abort and reject on timeout\n     */\n\n    timeout = setTimeout(function () {\n      httpRequest.abort();\n      defer.reject(new Response(405, {}, 'timeout exceeded'));\n    }, request.timeout);\n    /**\n     * Reject on error and pass the given error object\n     */\n\n    httpRequest.on('error', function (error) {\n      defer.reject(error);\n    });\n    httpRequest.end(request.getBody());\n    return defer.promise;\n  }\n\n  function isRedirect(statusCode) {\n    return statusCode === 301 || statusCode === 302 || statusCode === 303 || statusCode === 304 || statusCode === 307;\n  }\n  /**\n   * Request router, handles caching\n   * @param {Request} request\n   * @returns {Q.promise}\n   */\n\n\n  function callRouter(request) {\n    var defer = Q.defer();\n\n    if (!cache.isTransportAvailable() || request.method !== 'GET' || request.cache.cache === false) {\n      return call(request, defer);\n    }\n\n    function expirationTime(data) {\n      return data.created + request.cache.expires;\n    }\n    /**\n     * Get the cache and serve if available\n     */\n\n\n    cache.get(request.getFullUrl()).then(function (data) {\n      if (!data || expirationTime(data) <= new Date().getTime()) {\n        call(request, defer);\n        return;\n      }\n\n      defer.resolve(new Response(data.code, data.headers, data.body));\n    }).fail(function () {\n      call(request, defer);\n    });\n    return defer.promise;\n  }\n  /**\n   * Module API\n   * @type {{request: Function, responseEncoding: Function, get: Function, post: Function, put: Function, delete: Function, head: Function }}\n   */\n\n\n  api = {\n    /**\n     * Execute HTTP request based on the given method and body\n     * @param {string} url - The URL to execute\n     * @param {{ method: string, dataType: string, headers: object, body: object, cookies: object, auth: object }} options\n     * @returns {Q.promise} - Returns a promise, once resolved || rejected, Response object is given\n     */\n    request: function request(url, options) {\n      return callRouter(new Request(url, options));\n    },\n\n    /**\n     * Getter/setter for the response encoding\n     * @param {string} value\n     * @returns {string|Requestify}\n     */\n    responseEncoding: function responseEncoding(value) {\n      if (!value) {\n        return _responseEncoding;\n      }\n\n      _responseEncoding = value;\n      return this;\n    },\n\n    /**\n     * Getter/Setter for the redis instance\n     * @deprecated\n     * @param {Redis} redisInstance\n     */\n    redis: function redis(redisInstance) {\n      if (!redisInstance) {\n        return;\n      }\n\n      this.cacheTransporter(redisTransporter(redisInstance));\n    },\n\n    /**\n     * Module core transporters\n     */\n    coreCacheTransporters: {\n      redis: redisTransporter,\n      mongo: mongoTransporter,\n      inMemory: inMemoryTransporter\n    },\n\n    /**\n     * Module core log adapters\n     */\n    coreLoggerAdapters: {\n      console: require('./logger-adapters/console-adapter'),\n      winston: require('./logger-adapters/winston-adapter')\n    },\n\n    /**\n     * Set cache transporter\n     * @param {{ get: function, set: function, purge: function }} cacheTransporter\n     */\n    cacheTransporter: function cacheTransporter(_cacheTransporter) {\n      if (!_cacheTransporter) {\n        return;\n      }\n\n      cache.setCacheTransporter(_cacheTransporter);\n    },\n\n    /**\n     * Set custom log adapter\n     * @param {{ error: function, info: function, debug: function, warning: function }} logAdapter\n     */\n    logAdapter: function logAdapter(_logAdapter) {\n      if (!_logAdapter) {\n        return;\n      }\n\n      logger.setLogger(_logAdapter);\n    },\n\n    /**\n     * Proxy function for determining logging level\n     * @param {number} level - Number between 0 - 3 (e.g. 0 - error, 1 - warn, 2 - info, 3 - debug)\n     */\n    logLevel: function logLevel(level) {\n      if (isNaN(level)) {\n        throw new Error('Level must be a number');\n      }\n\n      logger.logLevel(level);\n    }\n  };\n  /**\n   * Short methods generator\n   */\n\n  (function createShortMethods(names) {\n    names.forEach(function (name) {\n      api[name] = function (url, options) {\n        options = options || {};\n        options.method = name.toUpperCase();\n        return api.request(url, options);\n      };\n    });\n  })(['get', 'delete', 'head']);\n  /**\n   * Short methods with data generator\n   */\n\n\n  (function createShortMethodsWithData(names) {\n    names.forEach(function (name) {\n      api[name] = function (url, data, options) {\n        options = options || {};\n        options.method = name.toUpperCase();\n        options.body = data;\n        return api.request(url, options);\n      };\n    });\n  })(['post', 'put']);\n\n  return api;\n}();\n\nmodule.exports = Requestify;","map":null,"metadata":{},"sourceType":"script"}